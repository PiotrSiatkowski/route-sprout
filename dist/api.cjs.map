{"version":3,"sources":["../src/api.ts"],"sourcesContent":["import {\n\tKebabToCamel,\n\tKeep,\n\tPath,\n\tPathDef,\n\tRoutesFromDefs,\n\tSParams,\n\tSegment,\n\tSlot,\n\tSlotDef,\n\tWrap,\n} from './dsl'\n\n// ---------- Transform helpers ------------\nconst toCamel = (s: string) => s.replace(/-([a-zA-Z0-9])/g, (_, c) => c.toUpperCase())\ntype KeyFromSeg<S extends string> = KebabToCamel<S>\n\n// ---------- DSL helpers (typed) ----------\nexport const keep = (): Keep => ({ kind: 'keep' })\n\nexport const path = <\n\tconst Name extends string,\n\tconst Rest extends readonly PathDef[] = readonly [],\n>(\n\tname: Name,\n\trest?: Rest\n): Path<Name, KeyFromSeg<Name>, Rest> => ({\n\tkind: 'path',\n\tname: assertValidName('path', name),\n\tuuid: toCamel(name) as KeyFromSeg<Name>,\n\trest: (rest ?? []) as Rest,\n})\n\nexport const slot = <\n\tconst Name extends string,\n\tconst Rest extends readonly PathDef[] = readonly [],\n>(\n\tname: Name,\n\trest?: Rest\n): Slot<Name, KeyFromSeg<Name>, Rest> => ({\n\tkind: 'slot',\n\tname: assertValidName('slot', name),\n\tuuid: toCamel(name) as KeyFromSeg<Name>,\n\trest: (rest ?? []) as Rest,\n})\n\nexport const wrap = <\n\tconst Name extends string,\n\tconst Rest extends readonly PathDef[] = readonly [],\n\tArgs = unknown,\n>(\n\tname: Name,\n\twhen: (args: Args) => boolean,\n\trest?: Rest\n): Wrap<Name, KeyFromSeg<Name>, Rest, Args> => ({\n\tkind: 'wrap',\n\tname: assertValidName('wrap', name),\n\tuuid: toCamel(name) as KeyFromSeg<Name>,\n\twhen,\n\trest: (rest ?? []) as Rest,\n})\n\nconst IDENT = /^[A-Za-z_][A-Za-z0-9_]*$/\n\nfunction assertValidName<const Name extends string>(\n\tkind: 'path' | 'slot' | 'wrap',\n\tname: Name\n): Name {\n\t// Allow your synthetic node(\"\") only for nodes (internal)\n\tif (kind === 'path' && name === '') return name.trim() as Name\n\n\tif (!name) throw new Error(`${kind} name cannot be empty`)\n\tif (!IDENT.test(name)) {\n\t\tthrow new Error(\n\t\t\t`${kind} name \"${name}\" must be a valid identifier (letters/digits/_/$, not starting with a digit).`\n\t\t)\n\t}\n\n\treturn name.trim() as Name\n}\n\n// ---------- Runtime implementation ----------\nconst url = (path: Segment[], search?: SParams) =>\n\t`/${path.filter(Boolean).join('/').replace('/\\/{2,}/g', '/')}${search ? `?${search}` : ''}`\n\n// ---------- Typed root signature ----------\nexport function root<const Defs extends readonly PathDef[]>(defs: Defs): RoutesFromDefs<Defs> {\n\treturn buildPath([], path('', defs)) as unknown as RoutesFromDefs<Defs>\n}\n\nfunction buildPath(prefix: Segment[], def: SlotDef) {\n\tconst hasKeep = (pathDef: SlotDef) => pathDef.rest.some((c: any) => c.kind === 'keep')\n\tconst allPath =\n\t\tdef.kind === 'slot' || def.kind === 'wrap'\n\t\t\t? prefix\n\t\t\t: def.uuid\n\t\t\t\t? [...prefix, def.uuid]\n\t\t\t\t: prefix\n\n\t// If there is a keep(), the path itself is callable and acts as \"keep\"\n\tconst target: any = hasKeep(def)\n\t\t? (search?: SParams) => url(allPath, search)\n\t\t: Object.create(null)\n\n\tfor (const child of def.rest) {\n\t\tif (child.kind === 'slot') {\n\t\t\tif (child.rest.length === 0) {\n\t\t\t\ttarget[child.uuid] = (param: Segment) => {\n\t\t\t\t\tconst leafPath = [...allPath, param]\n\t\t\t\t\tconst fn: any = (search?: SParams) => url(leafPath, search)\n\t\t\t\t\treturn attachWhenAndJoin(fn, leafPath, [])\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttarget[child.uuid] = (param: Segment) => {\n\t\t\t\t\t// Build subtree for nested parts under :id\n\t\t\t\t\t// Synthetic path with empty name so we don't add extra segment.\n\t\t\t\t\tconst subTree = buildPath([...allPath, param], child)\n\n\t\t\t\t\t// Attach children (info, activities, etc.) to that function\n\t\t\t\t\treturn Object.assign(\n\t\t\t\t\t\thasKeep(child)\n\t\t\t\t\t\t\t? (search?: SParams) => url([...allPath, param], search)\n\t\t\t\t\t\t\t: Object.create(null),\n\t\t\t\t\t\tsubTree\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (child.kind === 'path') {\n\t\t\tif (child.rest.length === 0) {\n\t\t\t\tconst leafPath = [...allPath, child.uuid]\n\t\t\t\tconst fn: any = (search?: SParams) => url(leafPath, search)\n\t\t\t\ttarget[child.uuid] = attachWhenAndJoin(fn, leafPath, [])\n\t\t\t} else {\n\t\t\t\ttarget[child.uuid] = buildPath(allPath, child)\n\t\t\t}\n\t\t} else if (child.kind === 'wrap') {\n\t\t\ttarget[child.uuid] = (arg: unknown) => {\n\t\t\t\tconst enabled = child.when(arg)\n\t\t\t\tconst wrapped = enabled ? [...allPath, child.uuid] : allPath\n\t\t\t\tconst subTree = buildPath(wrapped, child as any)\n\n\t\t\t\treturn Object.assign(\n\t\t\t\t\t// if wrap has keep(), it becomes callable at that point\n\t\t\t\t\thasKeep(child as any)\n\t\t\t\t\t\t? (search?: SParams) => url(wrapped, search)\n\t\t\t\t\t\t: Object.create(null),\n\t\t\t\t\tsubTree\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn attachWhenAndJoin(target, allPath, def.rest)\n}\n\nfunction attachWhenAndJoin(target: any, basePath: Segment[], rest: readonly PathDef[]) {\n\tconst when = (cond: boolean, seg: Segment | readonly Segment[]) => {\n\t\tconst nextPath = cond ? [...basePath, ...(Array.isArray(seg) ? seg : [seg])] : basePath\n\n\t\t// If this is a callable leaf (no children), preserve callability after .when().\n\t\tif (rest.length === 0 && typeof target === 'function') {\n\t\t\tconst leaf: any = (search?: SParams) => url(nextPath, search)\n\t\t\treturn attachWhenAndJoin(leaf, nextPath, rest)\n\t\t}\n\n\t\t// Rebuild \"same subtree\" at a new prefix:\n\t\t// Use a synthetic path '' so we don't append an extra segment name.\n\t\treturn buildPath(nextPath, path('', rest))\n\t}\n\n\ttarget.$when = when\n\ttarget.$join = (seg: Segment | readonly Segment[]) => when(true, seg)\n\n\treturn target\n}\n"],"mappings":"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","names":["api_exports","__export","keep","path","root","slot","wrap","__toCommonJS","toCamel","s","_","c","name","rest","assertValidName","when","IDENT","kind","url","search","defs","buildPath","prefix","def","hasKeep","pathDef","allPath","target","child","param","leafPath","attachWhenAndJoin","subTree","fn","arg","wrapped","basePath","cond","seg","nextPath"]}