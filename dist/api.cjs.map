{"version":3,"sources":["../src/api.ts"],"sourcesContent":["import {\n\tBase,\n\tKeep,\n\tPath,\n\tPathDef,\n\tPick,\n\tRoutesFromDefs,\n\tSParams,\n\tSegment,\n\tSlot,\n\tSlotDef,\n\tToCamelCase,\n\tWrap,\n} from './dsl'\n\n// ---------- Transform helpers ------------\nconst toCamelCase = <S extends string>(s: S) =>\n\ts\n\t\t.replace(/^-+/, '')\n\t\t.replace(/-+$/, '')\n\t\t.replace(/^_+/, '')\n\t\t.replace(/_+$/, '')\n\t\t.replace(/-([a-zA-Z0-9])/g, (_, c) => c.toUpperCase())\n\t\t.replace(/_([a-zA-Z0-9])/g, (_, c) => c.toUpperCase()) as ToCamelCase<S>\n\nconst IDENT = /^[A-Za-z_-][A-Za-z0-9_-]*$/\n\nfunction assertValidName<const Name extends string>(\n\tkind: 'path' | 'slot' | 'wrap' | 'pick',\n\tname: Name\n): Name {\n\t// Allow your synthetic node(\"\") only for nodes (internal)\n\tif (kind === 'path' && name === '') return name.trim() as Name\n\n\tif (!name) throw new Error(`${kind} name cannot be empty`)\n\tif (!IDENT.test(name)) {\n\t\tthrow new Error(\n\t\t\t`${kind} name \"${name}\" must be a valid identifier (letters/digits/_/$, not starting with a digit).`\n\t\t)\n\t}\n\n\treturn name.trim() as Name\n}\n\nconst toSegs = (seg: Segment | readonly Segment[]) => (Array.isArray(seg) ? seg : [seg])\n\n// ---------- DSL helpers (typed) ----------\nexport const keep = (): Keep => ({ kind: 'keep' })\n\nexport const path = <\n\tconst Name extends string,\n\tconst List extends readonly PathDef[] = readonly [],\n>(\n\tname: Name,\n\tlist?: List\n): Path<Name, ToCamelCase<Name>, List> => ({\n\tkind: 'path',\n\tname: assertValidName('path', name),\n\tuuid: toCamelCase(name),\n\tlist: (list ?? []) as List,\n})\n\nexport const slot = <\n\tconst Name extends string,\n\tconst List extends readonly PathDef[] = readonly [],\n>(\n\tname: Name,\n\tlist?: List\n): Slot<Name, `$${ToCamelCase<Name>}`, List> => ({\n\tkind: 'slot',\n\tname: assertValidName('slot', name),\n\tuuid: `$${toCamelCase(name)}`,\n\tlist: (list ?? []) as List,\n})\n\nexport const wrap = <\n\tconst Name extends string,\n\tconst List extends readonly PathDef[] = readonly [],\n\tArgs = unknown,\n>(\n\tname: Name,\n\twhen: (args: Args) => boolean,\n\tlist?: List\n): Wrap<Name, `$${ToCamelCase<Name>}`, List, Args> => ({\n\tkind: 'wrap',\n\tname: assertValidName('wrap', name),\n\tuuid: `$${toCamelCase(name)}`,\n\twhen,\n\tlist: (list ?? []) as List,\n})\n\nexport const pick = <\n\tconst Name extends string,\n\tconst Mode extends Record<string, readonly Segment[]>,\n\tconst List extends readonly PathDef[] = readonly [],\n>(\n\tname: Name,\n\tmode: Mode,\n\tlist?: List\n): Pick<Name, `$${ToCamelCase<Name>}`, Mode, List> => ({\n\tkind: 'pick',\n\tname: assertValidName('pick', name),\n\tuuid: `$${toCamelCase(name)}`,\n\tmode,\n\tlist: (list ?? []) as List,\n})\n\nexport const base = <\n\tconst Segs extends Segment | readonly Segment[],\n\tconst List extends readonly PathDef[] = readonly [],\n>(\n\tsegs: Segs,\n\tlist?: List\n): Base<Segs, List> => ({ kind: 'base', segs, list: (list ?? []) as List })\n\nexport const root = <const Defs extends readonly PathDef[]>(defs: Defs): RoutesFromDefs<Defs> =>\n\tbuildNode([], path('', defs)) as unknown as RoutesFromDefs<Defs>\n\n// ---------- Runtime implementation ----------\nconst url = (path: Segment[], search?: SParams) =>\n\t`/${path\n\t\t.filter(Boolean)\n\t\t.join('/')\n\t\t.replace(/\\/{2,}/g, '/')}${search ? `?${search}` : ''}`\n\nfunction buildNode(prefix: Segment[], parent: SlotDef) {\n\tconst hasKeep = (pathDef: SlotDef) => pathDef.list.some((node: any) => node.kind === 'keep')\n\tconst allPath = parent.kind === 'path' && parent.name ? [...prefix, parent.name] : prefix\n\n\t// If there is a keep(), the path itself is callable and acts as \"keep\"\n\tconst target: any = makeTarget(hasKeep(parent), allPath)\n\n\tfor (const child of parent.list) {\n\t\tif (child.kind !== 'keep') {\n\t\t\tif (child.uuid in target) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Duplicate uuid \"${String(child.uuid)}\" under \"${allPath.join('/') || '/'}\"`\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\n\t\tif (child.kind === 'base') {\n\t\t\tconst nextPrefix = [...allPath, ...toSegs(child.segs)]\n\t\t\tconst sub: any = buildNode(nextPrefix, path('', child.list))\n\n\t\t\tfor (const key of Reflect.ownKeys(sub)) {\n\t\t\t\tif (key === '$when' || key === '$join') continue\n\t\t\t\tconst desc = Object.getOwnPropertyDescriptor(sub, key)\n\t\t\t\tif (!desc?.enumerable) continue\n\n\t\t\t\tif (key in target) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`base() merge collision on key \"${String(key)}\" under \"${allPath.join('/') || '/'}\"`\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\tObject.defineProperty(target, key, desc)\n\t\t\t}\n\t\t} else if (child.kind === 'slot') {\n\t\t\ttarget[child.uuid] = function bind(param: Segment) {\n\t\t\t\tconst next = [...allPath, param]\n\n\t\t\t\t// leaf slot => callable endpoint directly\n\t\t\t\tif (child.list.length === 0) {\n\t\t\t\t\treturn attachWhenAndJoin(makeTarget(true, next), next, [])\n\t\t\t\t}\n\n\t\t\t\t// non-leaf => subtree (optionally callable if keep())\n\t\t\t\treturn Object.assign(makeTarget(hasKeep(child), next), buildNode(next, child))\n\t\t\t}\n\t\t} else if (child.kind === 'path') {\n\t\t\tif (child.list.length === 0) {\n\t\t\t\tconst leafPath = [...allPath, child.name]\n\t\t\t\ttarget[child.uuid] = attachWhenAndJoin(makeTarget(true, leafPath), leafPath, [])\n\t\t\t} else {\n\t\t\t\ttarget[child.uuid] = buildNode(allPath, child)\n\t\t\t}\n\t\t} else if (child.kind === 'wrap') {\n\t\t\ttarget[child.uuid] = function wrap(arg: unknown) {\n\t\t\t\tconst enabled = child.when(arg)\n\t\t\t\tconst wrapped = enabled ? [...allPath, child.name] : allPath\n\t\t\t\tconst subTree = buildNode(wrapped, child)\n\n\t\t\t\treturn Object.assign(makeTarget(hasKeep(child), wrapped), subTree)\n\t\t\t}\n\t\t} else if (child.kind === 'pick') {\n\t\t\ttarget[child.uuid] = (value: keyof typeof child.mode) => {\n\t\t\t\tif (child.mode[value]) {\n\t\t\t\t\treturn buildNode([...allPath, ...child.mode[value]], path('', child.list))\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(`pick(\"${child.name}\") got unknown value: ${String(value)}`)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn attachWhenAndJoin(target, allPath, parent.list)\n}\n\nfunction attachWhenAndJoin(target: any, basePath: Segment[], list: readonly PathDef[]) {\n\tconst when = (cond: boolean, seg: Segment | readonly Segment[]) => {\n\t\tconst nextPath = cond ? [...basePath, ...toSegs(seg)] : basePath\n\n\t\t// If this is a callable leaf (no children), preserve callability after .when().\n\t\tif (list.length === 0 && typeof target === 'function') {\n\t\t\treturn attachWhenAndJoin(makeTarget(true, nextPath), nextPath, list)\n\t\t}\n\n\t\t// Rebuild \"same subtree\" at a new prefix:\n\t\t// Use a synthetic path '' so we don't append an extra segment name.\n\t\treturn buildNode(nextPath, path('', list))\n\t}\n\n\ttarget.$when = when\n\ttarget.$join = function join(seg: Segment | readonly Segment[]) {\n\t\treturn when(true, seg)\n\t}\n\n\treturn target\n}\n\nconst makeTarget = (callable: boolean, currentPath: Segment[]) => {\n\treturn callable ? (search?: SParams) => url(currentPath, search) : Object.create(null)\n}\n"],"mappings":"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","names":["api_exports","__export","base","keep","path","pick","root","slot","wrap","__toCommonJS","toCamelCase","s","_","c","IDENT","assertValidName","kind","name","toSegs","seg","list","when","mode","segs","defs","buildNode","url","search","prefix","parent","hasKeep","pathDef","node","allPath","target","makeTarget","child","nextPrefix","sub","key","desc","param","next","attachWhenAndJoin","leafPath","arg","wrapped","subTree","value","basePath","cond","nextPath","callable","currentPath"]}