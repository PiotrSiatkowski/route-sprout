{"version":3,"sources":["../src/api.ts"],"sourcesContent":["import { Keep, Path, Wrap, Slot, PathDef, SlotDef, Segment, SParams, RoutesFromDefs } from './dsl'\n\n// ---------- DSL helpers (typed) ----------\nexport const keep = (): Keep => ({ kind: 'keep' })\n\nexport const path = <\n\tconst Name extends string,\n\tconst Rest extends readonly PathDef[] = readonly [],\n>(\n\tname: Name,\n\trest?: Rest\n): Path<Name, Rest> => ({ kind: 'path', name, rest: (rest ?? []) as Rest })\n\nexport const slot = <\n\tconst Name extends string,\n\tconst Rest extends readonly PathDef[] = readonly [],\n>(\n\tname: Name,\n\trest?: Rest\n): Slot<Name, Rest> => ({ kind: 'slot', name, rest: (rest ?? []) as Rest })\n\nexport const wrap = <\n\tconst Name extends string,\n\tconst Rest extends readonly PathDef[] = readonly [],\n\tArgs = unknown,\n>(\n\tname: Name,\n\twhen: (args: Args) => boolean,\n\trest?: Rest\n): Wrap<Name, Rest, Args> => ({ kind: 'wrap', name, when, rest: (rest ?? []) as Rest })\n\n// ---------- Runtime implementation ----------\nconst url = (path: Segment[], search?: SParams) =>\n\t`${path.filter(Boolean).join('/')}${search ? `?${search}` : ''}`.replace('//', '/')\n\n// ---------- Typed root signature ----------\nexport function root<const Defs extends readonly PathDef[]>(\n\tdefs: Defs\n): RoutesFromDefs<Defs> {\n\treturn buildPath([], path('/', defs)) as unknown as RoutesFromDefs<Defs>\n}\n\nfunction buildPath(prefix: Segment[], def: SlotDef) {\n\tconst hasKeep = (pathDef: SlotDef) => pathDef.rest.some((c) => c.kind === 'keep')\n\tconst allPath =\n\t\tdef.kind === 'slot' || def.kind === 'wrap'\n\t\t\t? prefix\n\t\t\t: def.name\n\t\t\t\t? [...prefix, def.name]\n\t\t\t\t: prefix\n\n\t// If there is a keep(), the path itself is callable and acts as \"keep\"\n\tconst target: any = hasKeep(def) ? (search?: SParams) => url(allPath, search) : {}\n\n\tfor (const child of def.rest) {\n\t\tif (child.kind === 'slot') {\n\t\t\tif (child.rest.length === 0) {\n\t\t\t\ttarget[child.name] = (param: Segment) => (search?: SParams) =>\n\t\t\t\t\turl([...allPath, param], search)\n\t\t\t} else {\n\t\t\t\ttarget[child.name] = (param: Segment) => {\n\t\t\t\t\t// Build subtree for nested parts under :id\n\t\t\t\t\t// Synthetic path with empty name so we don't add extra segment.\n\t\t\t\t\tconst subTree = buildPath([...allPath, param], child)\n\n\t\t\t\t\t// Attach children (info, activities, etc.) to that function\n\t\t\t\t\treturn Object.assign(\n\t\t\t\t\t\thasKeep(child)\n\t\t\t\t\t\t\t? (search?: SParams) => url([...allPath, param], search)\n\t\t\t\t\t\t\t: {},\n\t\t\t\t\t\tsubTree\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (child.kind === 'path') {\n\t\t\tif (child.rest.length === 0) {\n\t\t\t\ttarget[child.name] = (search?: SParams) => url([...allPath, child.name], search)\n\t\t\t} else {\n\t\t\t\ttarget[child.name] = buildPath(allPath, child)\n\t\t\t}\n\t\t} else if (child.kind === 'wrap') {\n\t\t\ttarget[child.name] = (arg: unknown) => {\n\t\t\t\tconst enabled = child.when(arg)\n\t\t\t\tconst wrapped = enabled ? [...allPath, child.name] : allPath\n\t\t\t\tconst subTree = buildPath(wrapped, child as any)\n\n\t\t\t\treturn Object.assign(\n\t\t\t\t\t// if wrap has keep(), it becomes callable at that point\n\t\t\t\t\thasKeep(child as any) ? (search?: SParams) => url(wrapped, search) : {},\n\t\t\t\t\tsubTree\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn attachWhenAndJoin(target, allPath, def.rest)\n}\n\nfunction attachWhenAndJoin(target: any, basePath: Segment[], rest: readonly PathDef[]) {\n\ttarget.when = (cond: boolean, seg: Segment | readonly Segment[]) => {\n\t\t// Rebuild \"same subtree\" at a new prefix:\n\t\t// Use a synthetic path '' so we don't append an extra segment name.\n\t\treturn buildPath(\n\t\t\tcond ? [...basePath, ...(Array.isArray(seg) ? seg : [seg])] : basePath,\n\t\t\tpath('', rest)\n\t\t)\n\t}\n\ttarget.join = (seg: Segment | readonly Segment[]) => {\n\t\treturn buildPath([...basePath, ...(Array.isArray(seg) ? seg : [seg])], path('', rest))\n\t}\n\n\treturn target\n}\n"],"mappings":"AAGO,IAAMA,EAAO,KAAa,CAAE,KAAM,MAAO,GAEnCC,EAAO,CAInBC,EACAC,KACuB,CAAE,KAAM,OAAQ,KAAAD,EAAM,KAAOC,GAAQ,CAAC,CAAW,GAE5DC,EAAO,CAInBF,EACAC,KACuB,CAAE,KAAM,OAAQ,KAAAD,EAAM,KAAOC,GAAQ,CAAC,CAAW,GAE5DE,EAAO,CAKnBH,EACAI,EACAH,KAC6B,CAAE,KAAM,OAAQ,KAAAD,EAAM,KAAAI,EAAM,KAAOH,GAAQ,CAAC,CAAW,GAG/EI,EAAM,CAACN,EAAiBO,IAC7B,GAAGP,EAAK,OAAO,OAAO,EAAE,KAAK,GAAG,CAAC,GAAGO,EAAS,IAAIA,CAAM,GAAK,EAAE,GAAG,QAAQ,KAAM,GAAG,EAG5E,SAASC,EACfC,EACuB,CACvB,OAAOC,EAAU,CAAC,EAAGV,EAAK,IAAKS,CAAI,CAAC,CACrC,CAEA,SAASC,EAAUC,EAAmBC,EAAc,CACnD,IAAMC,EAAWC,GAAqBA,EAAQ,KAAK,KAAMC,GAAMA,EAAE,OAAS,MAAM,EAC1EC,EACLJ,EAAI,OAAS,QAAUA,EAAI,OAAS,OACjCD,EACAC,EAAI,KACH,CAAC,GAAGD,EAAQC,EAAI,IAAI,EACpBD,EAGCM,EAAcJ,EAAQD,CAAG,EAAKL,GAAqBD,EAAIU,EAAST,CAAM,EAAI,CAAC,EAEjF,QAAWW,KAASN,EAAI,KACnBM,EAAM,OAAS,OACdA,EAAM,KAAK,SAAW,EACzBD,EAAOC,EAAM,IAAI,EAAKC,GAAoBZ,GACzCD,EAAI,CAAC,GAAGU,EAASG,CAAK,EAAGZ,CAAM,EAEhCU,EAAOC,EAAM,IAAI,EAAKC,GAAmB,CAGxC,IAAMC,EAAUV,EAAU,CAAC,GAAGM,EAASG,CAAK,EAAGD,CAAK,EAGpD,OAAO,OAAO,OACbL,EAAQK,CAAK,EACTX,GAAqBD,EAAI,CAAC,GAAGU,EAASG,CAAK,EAAGZ,CAAM,EACrD,CAAC,EACJa,CACD,CACD,EAESF,EAAM,OAAS,OACrBA,EAAM,KAAK,SAAW,EACzBD,EAAOC,EAAM,IAAI,EAAKX,GAAqBD,EAAI,CAAC,GAAGU,EAASE,EAAM,IAAI,EAAGX,CAAM,EAE/EU,EAAOC,EAAM,IAAI,EAAIR,EAAUM,EAASE,CAAK,EAEpCA,EAAM,OAAS,SACzBD,EAAOC,EAAM,IAAI,EAAKG,GAAiB,CAEtC,IAAMC,EADUJ,EAAM,KAAKG,CAAG,EACJ,CAAC,GAAGL,EAASE,EAAM,IAAI,EAAIF,EAC/CI,EAAUV,EAAUY,EAASJ,CAAY,EAE/C,OAAO,OAAO,OAEbL,EAAQK,CAAY,EAAKX,GAAqBD,EAAIgB,EAASf,CAAM,EAAI,CAAC,EACtEa,CACD,CACD,GAIF,OAAOG,EAAkBN,EAAQD,EAASJ,EAAI,IAAI,CACnD,CAEA,SAASW,EAAkBN,EAAaO,EAAqBtB,EAA0B,CACtF,OAAAe,EAAO,KAAO,CAACQ,EAAeC,IAGtBhB,EACNe,EAAO,CAAC,GAAGD,EAAU,GAAI,MAAM,QAAQE,CAAG,EAAIA,EAAM,CAACA,CAAG,CAAE,EAAIF,EAC9DxB,EAAK,GAAIE,CAAI,CACd,EAEDe,EAAO,KAAQS,GACPhB,EAAU,CAAC,GAAGc,EAAU,GAAI,MAAM,QAAQE,CAAG,EAAIA,EAAM,CAACA,CAAG,CAAE,EAAG1B,EAAK,GAAIE,CAAI,CAAC,EAG/Ee,CACR","names":["keep","path","name","rest","slot","wrap","when","url","search","root","defs","buildPath","prefix","def","hasKeep","pathDef","c","allPath","target","child","param","subTree","arg","wrapped","attachWhenAndJoin","basePath","cond","seg"]}